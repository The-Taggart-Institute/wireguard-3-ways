<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Wireguard 3 Ways: Cooking up Privacy in a Surveillance State</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wireguard 3 Ways: Cooking up Privacy in a Surveillance State</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="wireguard-3-ways-cooking-up-security-in-a-surveillance-state"><a class="header" href="#wireguard-3-ways-cooking-up-security-in-a-surveillance-state">Wireguard 3 Ways: Cooking Up Security in a Surveillance State</a></h1>
<p>This repository contains instructions and support files for the <a href="https://hope.net">HOPE</a> workshop.</p>
<h2 id="learning-objectives"><a class="header" href="#learning-objectives">Learning Objectives</a></h2>
<p>We break learning objectives into <strong>Skills</strong> and <strong>Concepts</strong>.</p>
<h3 id="skills"><a class="header" href="#skills">Skills</a></h3>
<p>By the end of this workshop, participants will be able to:</p>
<ul>
<li>Create Wireguard peers and servers</li>
<li>Establish Wireguard networks across NAT boundaries</li>
</ul>
<h3 id="concepts"><a class="header" href="#concepts">Concepts</a></h3>
<p>By the end of this workshop, participants will understand:</p>
<ul>
<li>Wireguard tunnel design</li>
<li>Wireguard asymmetric cryptography usage</li>
<li>Wireguard networking strategies</li>
<li>Basic mesh networking principals</li>
</ul>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<h3 id="technical-requirements"><a class="header" href="#technical-requirements">Technical Requirements</a></h3>
<p>This workshop uses <a href="https://podman.io">Podman</a> for its demonstrations. It can be installed on Linux, Windows or macOS. On Windows, Podman Desktop will require either <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL</a> or Hyper-V to virtualize a small Linux kernel. We will also use Podman Compose, which is a package install for Linux, but <a href="https://podman-desktop.io/docs/compose">Podman Desktop</a> can support this function as well.</p>
<p>The workshop will also use <a href="https://zellij.dev">Zellij</a> for easy terminal control of the containers. If not participating with the provided resources, I recommend installing it.</p>
<p>The containers will have several terminal-based text editors installed (Vim, Nano, Helix) to suit your preference. But you will be editing text in the terminal.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>Familiarity with the Linux command line will be extremely helpful in this workshop. As will familiarity with basic networking concepts such as subnets and firewall rules.</p>
<h3 id="cloud-vm"><a class="header" href="#cloud-vm">Cloud VM</a></h3>
<p>The Recipes provided in this repository are wholly self-contained. You can run them on any platform that supports Podman/Podman Compose. However, for full participation in the workshop, you will need two resources I can't provide for you:</p>
<ol>
<li>A registered domain name</li>
<li>A cloud-hosted virtual machine</li>
</ol>
<p>These are not zero-cost, zero-identity activities, and as such are optional. However, the workshop will involve demonstrating how to set up a real Wireguard network for use across the internet, which means public-facing assets. If you intend to fully participate in the workshop, these will be necessary.</p>
<p>I recommend <a href="https://porkbun.com">Porkbun</a> or <a href="https://namecheap.com">Namecheap</a> for a domain registrar, and <a href="https://digitalocean.com">Digital Ocean</a> for a VPS provider.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Here are provided 3 "recipes" for creating Wireguard networks, in increasing complexity—and utility. Each is comprised of <a href="https://podman.io">Podman</a> containers, networked together. They can be run on any platform that Podman supports, but for the HOPE workshop, a cloud VM will be provided for participants.</p>
<h3 id="zellij"><a class="header" href="#zellij">Zellij</a></h3>
<p>The recipes provded each have a startup script that performs some housekeeping on the Podman containers. It also launches a helper terminal multiplexer called <a href="https://zellij.dev">Zellij</a>. If you aren't using the provided resources, I recommend installing Zellij to make full use of the environment.</p>
<p>Zellij will create terminal windows for all necessary containers, as well as a separate window for interacting with the host itself. Zellij is mouse-sensitive and fairly intuitive—well, for a terminal tool.</p>
<h2 id="the-recipes"><a class="header" href="#the-recipes">The Recipes</a></h2>
<p>I know it says "3 ways" on the box, but actually we need to start with a fundamental dish before moving on to the real recipes.</p>
<h3 id="0-a-simple-mesh"><a class="header" href="#0-a-simple-mesh">0. A Simple Mesh</a></h3>
<p>In this recipe, all our peers live on the same network. That could make Wireguard redundant, but it will establish an additional layer of encryption on top of all peer-to-peer communications. This recipe is more about learning the concepts of Wireguard configurations. Each peer connects to every other peer via manual point-to-point connections. This works, but doesn't exactly scale.</p>
<h3 id="1-the-lighthouse"><a class="header" href="#1-the-lighthouse">1. The Lighthouse</a></h3>
<p>If we want to connect multiple hosts across networks, but we don't want to open inbound ports, we need to use a public server that all our peers can see. This "lighthouse" server will be the one to which all the others connect.</p>
<h3 id="2-the-lighthouse--subnet-router"><a class="header" href="#2-the-lighthouse--subnet-router">2. The Lighthouse + Subnet Router</a></h3>
<p>What if we want access to an entire home network without wanting to configure Wireguard on all of those devices? That's where "subnet routers" come in. This configuration allows a (Linux) Wireguard host to provide access to its neighbors through the Wireguard tunnel.</p>
<h3 id="3-the-coordinated-mesh"><a class="header" href="#3-the-coordinated-mesh">3. The Coordinated Mesh</a></h3>
<p>One of the shortcomings of the "lighthouse" model is that the lighthouse becomes a termination point for the Wireguard encrypted tunnel. If we have doubts about our cloud service provider, then any otherwise unencrypted traffic may be sniffed with access to this server. But we need a central point that everyone can see to guarantee connection. How to square this circle?</p>
<p><a href="https://tailscale.com">Tailscale</a> solves this problem by using multiple strategies to show peers how to connect, and then allows the peers to connect directly to each other, eliminating the machine-in-the-middle. And it's all built on top of Wireguard, so you get the same security with much less hassle.</p>
<p>But Tailscale is a cloud service. So suppose you didn't want to entrust your data there either? Luckily, the core of Tailscale is open source—both client daemon and server. <a href="https://headscale.net">Headscale</a> is a way to self-host a Tailscale server and network. The setup for Headscale is <em>considerably</em> easier than raw Wireguard.</p>
<h2 id="how-to-use-this-repo"><a class="header" href="#how-to-use-this-repo">How to Use This Repo</a></h2>
<p>The source of this repo is fully readable here, but the online "book" version for easy reading is online at <a href="https://w3w.taggartinstitute.org">https://w3w.taggartinstitute.org</a>.</p>
<p>Read along and follow the provide instructions to participate in the workshop!</p>
<h2 id="instructions"><a class="header" href="#instructions">Instructions</a></h2>
<p>See the <a href="../docs/SUMMARY.html">docs</a> folder for the instructions. Or click next if you're reading the book!</p>
<blockquote>
<center><i>Made with 💜 by <a href="https://taggartinstitute.org">The Taggart Institute</a></i></center>
<center><img src="../logo.png" style="width: 250px; height: 250px; margin-top: 5px;" /></center>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whyreguard"><a class="header" href="#whyreguard">Why...reguard?</a></h1>
<p>Why do this at all? Why bother setting up a custom private network when there are so many services that will do it for you? And why choose Wireguard when other turnkey technologies like OpenVPN have been around for so long?</p>
<p>Let's get into it.</p>
<h2 id="trust-and-risk"><a class="header" href="#trust-and-risk">Trust and Risk</a></h2>
<p>If you're reading this, odds are you have a slightly different perspective on "the cloud" than most of the population. After all, it's just someone else's computer, right? Whenever you entrust your data to a third-party service, you are accepting some degree of risk to your data's confidentiality, integrity, and availability in that transaction. The service could go down due to demand, misconfiguration, or equipment failure (availability). Something could go catastrophically wrong with their infrastructure, leading to corrupting of data (integrity). Intentionally or otherwise, the service may enable others to view your data, even data intended to be secret (confidentiality).</p>
<p>These risks are hardly theoretical; we see the reality play out time and again.</p>
<p>Now imagine you're building a community that the government deems subversive. We don't even have to explore illegal activity, just activity that those in power don't like so much. Further imagine that you've entrusted your confidential data to a cloud service. In order to feel safe, you need the following guarantees:</p>
<ol>
<li>The service is doing everything securely on the technical level.</li>
<li>There are no existing compromises to the service or technologies used by the service.</li>
<li>The service will be less than eager to cooperate with a subpoena or a warrant.</li>
</ol>
<p>Despite the marketing, the use of most commercial VPNs is an act of transferring risk not mitigating it. You've moved the need to trust your internet service provider to the need to trust your VPN—in some cases, due to common misconfigurations, data actually ends up going both to the ISP <em>and</em> the VPN, meaning you've now increased your risk profile.</p>
<p>But either way, you still have to trust those services. Some are probably trustworthy, but a system that relies on only a few good actors is a fragile system indeed. Instead, I'd like to build a private networking landscape in which many individuals can and do create the networks they require.</p>
<h2 id="the-threat-model"><a class="header" href="#the-threat-model">The Threat Model</a></h2>
<p>What exactly are we defending against here? This isn't really about criminals stealing your identity, much less machine-in-the-middle attacks at the coffee shop. What we're talking about here concerns community safety. Maybe you're organizing for political action. Maybe you're sharing media that those in power would rather not be shared. Maybe you're trying to run an independent news organization. Many forms of community have good reason to be concerned about an overzealous state attempting to monitor their communications and data archives. Entrusting all of this data to third parties who have more interest in cooperating with the state than protecting your privacy is a dicey situation.</p>
<h2 id="wireguard"><a class="header" href="#wireguard">Wireguard</a></h2>
<p>Wireguard offers the ability to create the kind of private network you <em>need</em>, not the one being sold to you. The tradeoff, at least in the more elementary setups, is knowing how the technology works. In this coming age, that knowledge is precious.</p>
<p>But what makes Wireguard so special as a technology? Four aspects make me very confident in networks built on Wireguard:</p>
<ol>
<li>Simplicity</li>
<li>Ubiquity</li>
<li>Performance</li>
<li>Cryptography</li>
</ol>
<h3 id="simplicity"><a class="header" href="#simplicity">Simplicity</a></h3>
<p>Compared to other VPN technologies like OpenVPN or IPSec, Wireguard is extremely simple at its core. As this workshop demonstrates, a basic mesh is hardly more than a few lines of config—and that's before we get to the rich ecosystem of tools built on Wireguard, some of which we'll explore during this workshop.</p>
<h3 id="ubiquity"><a class="header" href="#ubiquity">Ubiquity</a></h3>
<p>Wireguard is a Linux kernel module. That means every modern Linux machine has the capability of being a Wireguard node, and its residence in the kernel ensures a speedy pipeline to the networking hardware. But that's not all. Wireguard clients exist of Windows and macOS, as well as iOS and Android mobile operating systems. And because the Wireguard technology is licensed entirely under free and open source licenses, I don't expect it to disappear anytime soon.</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>Wireguard <a href="https://www.wireguard.com/performance/">routinely outperforms</a> other private networking technologies in throughput benchmarks. Anecdotally, I have experienced this reality. I have run full RDP sessions from conferences back to my lab at home over Wireguard, without a moment's hiccucp. If Wireguard can achieve <a href="https://netseccloud.com/understanding-line-rate-in-networking-a-comprehensive-guide">line rate</a> on a gigabit card, that means your VPN layer is not a bottleneck in the communication.</p>
<h3 id="cryptography"><a class="header" href="#cryptography">Cryptography</a></h3>
<p>I encourage you to review the <a href="https://www.wireguard.com/protocol/">cryptographic details</a> of the Wireguard protocol, if you're so inclined. I will never call myself a cryptography expert, but the ciphers in use and how they're used have been independently tested and attested. I'm confident in the cryptographic strength of the protocol.</p>
<h2 id="fun"><a class="header" href="#fun">Fun</a></h2>
<p>This seems like it shouldn't matter, but it kind of does. If you've done any kind of network engineering, you know what an utter slog it can be. I shudder when I think of the nights I spent reconfiguring VLANs on Cisco switches a lifetime ago.</p>
<p>Wireguard doesn't feel like that. Setting up Wireguard networks is, dare I say it, pretty fun! Yes it's technical, but straightforward enough to make sense to most curious users. And because Wireguard itself is so simple, making it work often reveals other surprises in your network topology.</p>
<p>So that's why Wireguard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-0-a-simple-mesh"><a class="header" href="#recipe-0-a-simple-mesh">Recipe 0: A Simple Mesh</a></h1>
<p>We begin our Wireguard journey with the most elemental model: peers connecting to one another. This recipe sets up three hosts, with connections amongst them.</p>
<pre class="mermaid">flowchart TD
    B[&quot;Peer 1&quot;] &lt;--&gt; C[&quot;Peer 2&quot;] &amp; D[&quot;Peer 3&quot;]
    C &lt;--&gt; D
    B@{ shape: rect}
    style B stroke:#D50000
    style C stroke:#00C853
    style D stroke:#2962FF
</pre>
<h2 id="wireguard-config"><a class="header" href="#wireguard-config">Wireguard Config</a></h2>
<p>We need to get acquainted with the Wireguard config file. Take a look at <code>peer.conf</code>.</p>
<h3 id="interface"><a class="header" href="#interface"><code>Interface</code></a></h3>
<p>Each peer defines the details of its own Wireguard interface in the <code>[Interface]</code> section. Here the private portion of our keypair is defined. The public key derives from the private key, and for convenience I like to keep the public key in a comment alongide the private.</p>
<p>We also need to define the IP Address our peer will use on the Wireguard network. The ListenPort is optional, but it helps to define this explicitly so we can write firewall rules around known ports.</p>
<h3 id="peer"><a class="header" href="#peer"><code>Peer</code></a></h3>
<p>Peers sections are a little tricky. Depending on whether the Peer is connecting to us or we're connecting to it, we use the <code>Peer</code> section differently. When connecting <em>to</em> another Peer, we need an <code>Endpoint</code> directive that defines the non-Wireguard address and point where the Peer is located. We also use a <code>PersistentKeepalive</code> directive to keep the tunnel active with intermittent packets sent over the tunnel.</p>
<p>Now let's talk about <code>AllowedIPs</code>. This directive changes meaning depending on whether we're defining and incoming or outgoing connection. For incoming connections, <code>AllowedIPs</code> defines the IP addresses allowed in. Normally, this is a single IP address: the Wireguard address of the peer, written as in CIDR notation as a <code>/32</code> subnet.</p>
<p>For outgoing connections, <code>AllowedIPs</code> defines what addresses get routed over the tunnel. Normally then, this will be the full subnet of the Wireguard network, like <code>172.16.100.0/24</code>. Later, we'll learn some other tricks with <code>AllowedIPs</code>.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>From this folder, run <code>./start.sh</code>.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="writing-the-configuration"><a class="header" href="#writing-the-configuration">Writing the Configuration</a></h3>
<p>In this recipe, we do everything the hard way so you know how it all works. We automate most of this in later recipes.</p>
<p>With all the hosts up, we need to build the configurations on each peer. This begins with creating a public and private key for Wireguard to use. Run these commands on each peer, once they're up.</p>
<pre><code class="language-bash">privkey=$(wg genkey)
pubkey=$(echo $privkey | wg pubkey)
sed -i "s|&lt;&lt;PRIVATE_KEY&gt;&gt;|$privkey|" /etc/wireguard/recipe-0.conf
sed -i "s|&lt;&lt;PUBLIC_KEY&gt;&gt;|$pubkey|" /etc/wireguard/recipe-0.conf
</code></pre>
<p>This fills in the public/private key for each peer's configuration. But we're not finished. We also need to decide on IP addresses for each. I'd use the <code>172.16.100.0/24</code> subnet. So our IP addresses could be:</p>
<ul>
<li><code>172.16.100.1/24</code></li>
<li><code>172.16.100.2/24</code></li>
<li><code>172.16.100.3/24</code></li>
</ul>
<p>Those go in the <code>Address</code> section of each peer config.</p>
<p>Now for those <code>Peer</code> entries. For each host, we need to create two <code>[Peer]</code> entries. Peer 1 needs 2 and 3; Peer 2 needs 1 and 3; and Peer 3 needs 1 and 2.</p>
<p>For each of these, we'll need the IP address in the non-Wireguard network for our <code>Endpoint</code> field. Use <code>ip address show</code> (or <code>ip a s</code> for short) to get those addresses.</p>
<p>The <code>AllowedIPs</code> for each Peer will be the <code>/32</code> CIDR representation of their respective Wireguard IP addresses.</p>
<p>Finally, add the proper public key from each respective configuration to the appropriate <code>Peer</code> entry for all the configuration files. Save all these files and quit back to the containers' terminal prompts.</p>
<h3 id="bring-up-the-wireguard-network"><a class="header" href="#bring-up-the-wireguard-network">Bring up the Wireguard Network</a></h3>
<p>On each host, run <code>wg-quick up recipe-0</code> to activate the Wireguard tunnel.</p>
<p>You can then run <code>wg show</code> to show the status of the tunnel. If all has gone according to plan, you should have three hosts each showing two connections to other peers. You should also be able to ping those <code>172.16.100.0/24</code> addresses.</p>
<p>Congratulations! You brought up a Wireguard mesh the hard way. The subsequent recipes automate a lot of the busywork now that you've had exposure to the concepts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-1-the-lighthouse"><a class="header" href="#recipe-1-the-lighthouse">Recipe 1: The Lighthouse</a></h1>
<p>Our next Recipe simplifies our configuration by using a central "server" to which all other Peers connect. We call this server a "lighthouse" both because everyone needs to be able to see it, and because it will be hanging out there on rocky shores, also known as "the cloud."</p>
<p>In the Podman demo, the Lighthouse is just in another network segment. But in real-world application, you want the Lighthouse to be hosted someplace that's accessible anywhere in the world.</p>
<pre class="mermaid">flowchart TD
    Lighthouse[&quot;Lighthouse🔦&quot;] --- Peer[&quot;wg-home&quot;] &amp; n2[&quot;wg-roaming&quot;]

    style Lighthouse stroke:#2962FF
    style Peer stroke:#00C853
    style n2 stroke:#D50000
</pre>
<h2 id="different-networks"><a class="header" href="#different-networks">Different Networks</a></h2>
<p>Have a look at <code>podman-compose.yml</code> in this folder. You don't need to understand all the syntax here, but notice that each entry in the <code>services</code> section has a <code>networks</code> field. And there's a corresponding <code>networks</code> section at the bottom of the file. We have two networks defined: <code>roaming</code>, which is a stand-in for "the internet and everything not our home network," and <code>home</code>.</p>
<p>Imagine being on hotel Wi-Fi. You can't directly see a Wireguard peer that's back at home since it's behind a different router. We could open up ports on our home router, but that comes with pretty significant risks that we're trying to avoid here. Instead, we want a single point that all our Peers can see at once. That's our Lighthouse, and the easiest place to set one up is on a public cloud hosting provider. Our Podman deployment simulates that arrangement without the need for creating a cloud virtual machine.</p>
<p>There's one other important aspect of the setup visible in this file. Take a look at the <code>lighthouse</code> entry. You'll see a section that reads:</p>
<pre><code class="language-yaml">sysctls:
  net.ipv4.ip_forward: 1
</code></pre>
<p>This configures the lighthouse server to forward IP packets on to their intended destination using the system's routing. That means if it receives a packet intended for someone else—like say one Peer trying to reach another—it will forward the packet along however it knows how. This setting is how we turn a single Wireguard Peer into a lighthouse that allows many hosts to interconnect through one point. This trick is also why the lighthouse server is always a Linux/Unix-like device. IP forwarding is very simple to get going on these operating systems.</p>
<h2 id="recipe-setup"><a class="header" href="#recipe-setup">Recipe Setup</a></h2>
<p>In the <code>recipe-1</code> folder, run the <code>start.sh</code> script to bring up our peers.</p>
<h2 id="wireguard-config-1"><a class="header" href="#wireguard-config-1">Wireguard Config</a></h2>
<p>This time, each host's Wireguard config (<code>/etc/wireguard/recipe-1.conf</code>) has a keypair configured. What remains is for us to connect the two peers to the lighthouse.</p>
<p>In this model, each non-lighthouse Peer adds the same information to their <code>Peer</code> entry: the lighthouse's public key and IP address, and setting AllowedIPs to the whole <code>/24</code> subnet we're using for Wireguard (i.e. <code>172.16.100.0/24</code>). That way, all traffic to any IP address in that subnet will be routed to the lighthouse.</p>
<p>For the lighthouse, a separate <code>[Peer]</code> entry is required for each Peer, but no <code>Endpoint</code> or <code>PersistentKeepalive</code> directives. That's because the lighthouse only <em>receives</em> tunnels; it does not initiate them. The <code>AllowedIPs</code> field for each peer will be the single IP address assigned to that Peer, written as a <code>/32</code> CIDR.</p>
<p>Again, use <code>wg-quick up recipe-1</code> to initiate the tunnels, and <code>wg-show</code> to view the tunnel status.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>Try pinging one Wireguard address from the other! Also, you can try using <code>netcat</code> to simulate some network traffic. One one peer, run:</p>
<pre><code class="language-bash">nc -nvlp 8000
</code></pre>
<p>This sets up a TCP listener on port 8000. Then, on the other peer, run:</p>
<pre><code class="language-bash">nc &lt;peer_wireguard_ip&gt; 8000
</code></pre>
<p>You should see a TCP connection established!</p>
<h2 id="addendum-the-road-warrior"><a class="header" href="#addendum-the-road-warrior">Addendum: The Road Warrior</a></h2>
<p>There's a common Wireguard setup known as the "Road Warrior" that we are conspicuously ignoring in this workshop. The Road Warrior looks like this:</p>
<pre class="mermaid">flowchart TD
 subgraph s1[&quot;Home Network&quot;]
        Home[&quot;Home Hosts&quot;]
        n3[&quot;Wireguard Router&quot;]
  end
    n3 --- Home
    Roaming[&quot;Roaming&quot;] ---&gt; s1

    style Roaming stroke:#2962FF
    style s1 fill:#BBDEFB
</pre>
<p>Instead of relying on a cloud-hosted server, the Road Warrior opens a port on one's home router, and connects back to that router and linked hosts via that open port. It's simpler, but depending on your threat model, a bit more dangerous. Personally, I consider my home router as a questionable ally at best, given the focus those devices receive from my adversaries. Entrusting a cloud hosting provider can also be quite risky, and there are some I wouldn't use for this purpose, but for me, I'd much rather move the risk to that third party than in my own house.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-2-the-lighthouse--subnet-router"><a class="header" href="#recipe-2-the-lighthouse--subnet-router">Recipe 2: The Lighthouse + Subnet Router</a></h1>
<p>This one is a minor modification of the Lighthouse from the last recipe, but an important one. The lighthouse as we defined it works great to connect Wireguard clients together, but what about devices that can't run Wireguard? What if you just <em>have</em> to have access to that sweet, sweet Brother printer in your home office? Or more modernly, what if you want to access your local-only security cameras?</p>
<p>In this recipe, one of our Peers connecting to the lighthouse has a trick up its sleeve. Despite being an ordinary Linux box, it serves as a router, allowing Wireguard peers to access the networks it can access. This "subnet router" provides Wireguard clients access to an entire home network through a single node.</p>
<pre class="mermaid">flowchart TD
 subgraph s1[&quot;Home network&quot;]
        n2[&quot;Home Node&quot;]
        n4[&quot;Webserver&quot;]
  end
 subgraph s2[&quot;Roaming network&quot;]
        n3[&quot;Roaming Node&quot;]
  end
 subgraph s3[&quot;Internet&quot;]
        n1[&quot;Lighthouse&quot;]
  end
    n2 &lt;---&gt; s3
    s2 &lt;---&gt; s3
    n2 &lt;---&gt; n4

    n2@{ shape: rounded}
    n3@{ shape: rounded}
    n1@{ shape: rounded}
    style n2 stroke:#2962FF
    style n3 stroke:#AA00FF
    style n1 stroke:#D50000
    style s1 fill:#BBDEFB
    style s2 fill:#E1BEE7
</pre>
<h2 id="lab-setup"><a class="header" href="#lab-setup">Lab Setup</a></h2>
<p>In the <code>recipe-2</code> folder, run the <code>start.sh</code> script. As before, this will initialize the Podman containers. This lab starts 4 containers:</p>
<ol>
<li>The home router</li>
<li>A non-Wireguard webserver on the home network</li>
<li>A roaming Wireguard client on a separate network</li>
<li>The lighthouse server</li>
</ol>
<p>To save a little time, this lab setup automates the assignment of Wireguard IP addresses in the config files.</p>
<h2 id="router-config"><a class="header" href="#router-config">Router Config</a></h2>
<p>To see how this works, take a look at <code>home-router/home-router.conf</code>. It's a Wireguard config, similar to the ones we've seen previously, but this one has a whole mess of <code>PostUp</code> and <code>PostDown</code> commands. Wireguard allows you to execute arbitrary commands upon startup aand shutdown. These commands set up firewalls rules to forward IP traffic from the Wireguard interface to the router's local interface, and "masquerade" the IP address—that is, pretend the packet is from the route rinternally, but translate it back to the original source once a response is received.</p>
<blockquote>
<p>The commands here use <a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page">nftables</a> to create the firewall rules. NFTables is the successor to iptables, but the syntax is way more arcane. In your own configs, if you prefer iptables or firewalld commands, that's just fine.</p>
</blockquote>
<p>This works in conjunction with the IP forwarding configuration on the lighthouse. Not much changes from the last configuration, save for the <code>AllowedIPs</code> field of the <code>[Peer]</code> config for our home router. While every other peer connecting to the lighthouse has a single IP in this field, the home router has a single IP, <em>and</em> the whole home subnet. That looks like:</p>
<pre><code>AllowedIPs = 172.16.100.2/32, 192.168.99.0/24
</code></pre>
<p>When a request for a home network address comes over the lighthouse tunnel, the lighthouse will use its routing rules (created by Wireguard) to send the traffic down to the home router. The home router, in turn, handles the traffic with its firewall rules. And that's how we present an entire home network to Wireguard via one—well two—peers.</p>
<p>That same <code>AllowedIPs</code> pattern is necessary on all the clients we want to access the home network via the Wireguard tunnel. Remember that on clients, <code>AllowedIPs</code> amounts to a routing rule for the Wireguard tunnel. So our roaming client's <code>Peer</code> entry for the lighthouse, the <code>AllowedIPs</code> section looks like:</p>
<pre><code>AllowedIPs = 172.16.100.0/24, 192.168.99.0/24     
</code></pre>
<h2 id="lab-exercises"><a class="header" href="#lab-exercises">Lab Exercises</a></h2>
<h3 id="tracepath"><a class="header" href="#tracepath">Tracepath</a></h3>
<p>We can use <code>tracepath</code> to confirm that traffic to the <code>192.168.99.0/24</code> network is being routed over Wireguard. From the roaming client, run:</p>
<pre><code class="language-bash">tracepath 192.168.99.10
</code></pre>
<p>The hops you see should be all <code>172.16.100.0/24</code> addresses until the very end.</p>
<h3 id="curl"><a class="header" href="#curl">cURL</a></h3>
<p>We went to the trouble of setting up a webserver in the home network. Can you use <code>cURL</code> to access it from the roaming Wireguard client?</p>
<pre><code class="language-bash">curl http://192.168.99.10
</code></pre>
<p>Yay! Web traffic!</p>
<h3 id="the-dirty-secret"><a class="header" href="#the-dirty-secret">The Dirty Secret</a></h3>
<p>The lighthouse is doing its job, but there's a subtle flaw in this which, depending on your threat model, might be a dealbreaker.</p>
<p>Let's think about what happens with that HTTP request to our home webserver. The roaming client sends the HTTP request over the Wireguard tunnel, up to the lighthouse server, which forwards it on to the home router, which in turn forwards it to the webserver.</p>
<p>See the problem? Like I said, it's subtle.</p>
<p>The issue lies in the first forward. In order for the lighthouse server to determine how to route the incoming packets, the traffic must <em>exit</em> the Wireguard tunnel and be handled by the lighthouse's routing rules. And there's the rub: at that moment, as the traffic exits one Wireguard tunnel before being sent over another, the traffic is not encrypted by Wireguard. That means anyone who can listen to our lighthouse's traffic can read the raw traffic. And because our request was unencrypted HTTP, the request is fully visible.</p>
<p>We can demonstrate this by capturing packets on the lighthouse during the HTTP request. All the tools have been included in the containers to make this happen.</p>
<p>Start the capture on the lighthouse this way:</p>
<pre><code class="language-bash">tcpdump -i recipe-2 tcp port 80 -w curl.pcapng
</code></pre>
<p>This will listen to the Wireguard interface for HTTP traffic. Then on the roaming client:</p>
<pre><code class="language-bash">curl http://192.168.99.10?key=supersecretkey
</code></pre>
<p>Use <code>Ctrl+C</code> to stop the packet capture on the lighthouse. You can then use <code>tshark</code> (or <code>termshark</code> if you're feeling brave) to review the traffic. With <code>tshark</code>, the command would be:</p>
<pre><code class="language-bash">tshark -r curl.pcapng
</code></pre>
<p>See anything interesting?</p>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h3>
<p>We discussed in the rationale for Wireguard that many VPNs are just a shifting of risk from the ISP to the VPN. In this case, we have also introduced some potential risk. If someone besides us is snooping on the cloud virtual machine, we've lost our guarantee of confidentiality. Some cloud providers are more trustworthy than others. Personally, for the providers I use, I'm less concerned about that than I am with any potential compromises of home routers. Still, this is not a perfect end-to-end encryption solution.
But don't worry—we can do better.</p>
<p>When you're done exploring, stop the containers with <code>stop.sh</code> in the <code>recipe-2</code> folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-3-coordinate-mesh-with-headscale"><a class="header" href="#recipe-3-coordinate-mesh-with-headscale">Recipe 3: Coordinate Mesh with Headscale</a></h1>
<p>We've learned that the lighthouse model, while convenient, has a potentially critical shortcoming: the relay exposes traffic as it crosses from one Wireguard tunnel to another. That means if the underlying protocol (HTTPS, SSH, etc.) is not encrypted, the traffic is perfectly readable by another with <code>root</code> access to the lighthouse. This isn't a problem in a direct mesh network, since the traffic is sent directly to a given peer. Unfortunately, we can't easily do that with <em>just</em> Wireguard when we're traversing multiple routers and the internet.</p>
<p>Ideally we'd want the lighthouse to negotiate some sort of pathfinding for peers to connect directly to each other, and let the peer-to-peer traffic remain encrypted.</p>
<p>That's exactly what <a href="https://tailscale.com">Tailscale</a> does.</p>
<h2 id="tailscale"><a class="header" href="#tailscale">Tailscale</a></h2>
<p>Tailscale is a networking product built on Wireguard and designed for the exact use case we're describing: building custom secure networks across multiple NAT layers.</p>
<p>I'll let you dive into the details of <a href="https://tailscale.com/blog/how-tailscale-works">how Tailscale operates</a>, but essentially Tailscale adds a coordination component to the Wireguard network that allows peers connecting to the "coordination server" to discover the best way to directly connect to each other—even behind NAT. Tailscale adds a few other handy features, like mature authentication/authorization and access control.</p>
<p>Still, the Tailscale service is yet another service. Trustworthy? Probably, but I don't like needing to rely on third party services. Luckily, I don't have to, because Tailscale open sources almost all of its core code. The client and coordination server bases are available, and there is indeed an open source implementation of the coordination server known as <a href="https://headscale.net">Headscale</a></p>
<h2 id="headscale"><a class="header" href="#headscale">Headscale</a></h2>
<p>Headscale allows us to spin up our own mini-Tailscale, using the Tailscale client for connection and authentication. The Tailscale client is also cross-platform (including mobile).</p>
<p>Headscale is shockingly easy to get going. The <a href="https://headscale.net/stable/setup/install/official/">server installation documentation</a> is extremely clear, as are the <a href="https://github.com/juanfont/headscale/blob/main/config-example.yaml">configuration options</a> available.</p>
<p>This recipe shows Headscale in action in a safe, containerized environment. But if you're interested in "going live" in this workshop, it will be Headscale that we deploy to the cloud.</p>
<h2 id="lab-setup-1"><a class="header" href="#lab-setup-1">Lab Setup</a></h2>
<p>Navigate to <code>recipe-3</code> in your terminal.</p>
<p>Before starting the lab, you might want to review the config file at <code>headscale/config/config.yaml</code>. Here you can see how we configure Headscale for listening. What you won't see in this configuration is any concept of a user. For that, you might want to look at how we spin things up in <code>start.sh</code>. But you'll also have a chance to do this yourself in the lab.</p>
<p>As before, fire up the lab with <code>./start.sh</code>. Your Zellij session will show three terminals, but only two containers: the home and roaming clients. What's up with that? The leftmost terminal is still on the host, because all of the commands for the Headscale server are run <em>outside</em> the terminal. That's just how Headscale decided to set it up. We'll work with it.</p>
<h2 id="lab-exercises-1"><a class="header" href="#lab-exercises-1">Lab Exercises</a></h2>
<h3 id="run-headscale-commands"><a class="header" href="#run-headscale-commands">Run Headscale Commands</a></h3>
<p>On the left-hand terminal, we can run commands against our Headscale server with <code>podman container exec</code>. Let's check the status of our nodes with:</p>
<pre><code class="language-bash">podman container exec recipe-3_headscale headscale nodes list
</code></pre>
<p>We should see two online nodes.</p>
<h3 id="access-the-home-webserver"><a class="header" href="#access-the-home-webserver">Access the Home Webserver</a></h3>
<p>We once again have a home network webserver set up to test route advertisement. From the roaming client, run:</p>
<pre><code class="language-bash">tracepath 192.168.99.10
</code></pre>
<p>You should see hops that represent Tailscale nodes. That tells us that the <code>192.168.99.0/24</code> subnet is being properly routed across Tailscale.</p>
<p>You can of course then use <code>curl</code> to confirm it works.</p>
<h3 id="tailscale-hostnames"><a class="header" href="#tailscale-hostnames">Tailscale Hostnames</a></h3>
<p>From either client, run <code>tailscale status</code> to see the hostnames Tailscale associates with the IP addresses. Try using <code>ping</code> or <code>nc</code> to establish network connections using hostnames.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="going-live-leaving-the-test-kitchen"><a class="header" href="#going-live-leaving-the-test-kitchen">Going Live: Leaving the Test Kitchen</a></h1>
<p>Our recipes so far have demonstrated the concepts behind Wireguard networking in a safe, contained (and containerized) environment. But now it's time to start building our real private network. In this section, we walk through creating a real-deal Headscale server in the cloud.</p>
<blockquote>
<p>"But Taggart, you can't trust the cloud!"</p>
</blockquote>
<p>You can use a thing without trusting it. The value proposition of the cloud VM is its visibility from everywhere. But if we do this right (e.g. a proper Headscale setup), we won't be trusting it for too much. Its job will be to negotiate the initial connection between peers, and then let the Tailscale "magic" establish peer-to-peer connections, keeping the lighthouse out of the picture entirely.</p>
<p>Let's get going.</p>
<h2 id="required-materials"><a class="header" href="#required-materials">Required Materials</a></h2>
<p>This is the part of the workshop that costs some money. To complete this setup as we've done it, you'll need:</p>
<ol>
<li>A registered domain name that you can control</li>
<li>A cloud VM</li>
</ol>
<p>The cloud VM doesn't have to be huge. Entry-level VMs on all major VPSes will be just fine.</p>
<h2 id="create-the-cloud-vm"><a class="header" href="#create-the-cloud-vm">Create the Cloud VM</a></h2>
<p>It all starts with the cloud VM. I'm going to use <a href="https://digitalocean.com">Digital Ocean</a> to demo the process, but if you're comfortabel with <code>AWS|Azure|Vultr|Hetzner</code>, go for it.</p>
<p>For commonality's sake, we'll use Ubuntu 24.04 LTS as our base. However, this choice means we'll need to manually install a newer version of Podman than is available directly from the package manager.</p>
<p>Different cloud providers have different methods of securing their VMs, but I strongly recommend the following best practices:</p>
<ul>
<li>Use SSH Key authentication</li>
<li>Use firewall rules to limit SSH access to certain source IP addresses</li>
</ul>
<p>Log in to the VM via SSH (or cloud console, if appropriate).</p>
<h3 id="housekeeping"><a class="header" href="#housekeeping">Housekeeping</a></h3>
<p>We want to perform the following housekeeping measures, as needed:</p>
<ol>
<li>Create a new, non-root user</li>
<li>Make sure our SSH Keys are present on the new user and that we can log in with it</li>
<li>Disable root login</li>
<li>Add firewall rules to allow HTTP/HTTPS traffic (80/tcp, 443/tcp)</li>
</ol>
<blockquote>
<p>Hey if you wanna get extra sneaky, change the ports you're using for SSH and HTTPS, but for now we'll leave these default.</p>
</blockquote>
<h2 id="install-headscale"><a class="header" href="#install-headscale">Install Headscale</a></h2>
<p>Head to the <a href="https://github.com/juanfont/headscale/releases/latest">Headscale Releases</a> and download the latest Headscale version.</p>
<p>For our server, we want the <code>linux_amd64.deb</code> version. Copy that link's URL and then use it like so:</p>
<pre><code class="language-bash">wget https://github.com/juanfont/headscale/releases/download/v0.26.1/headscale_0.26.1_linux_amd64.deb
sudo dpkg -i headscale*.deb
</code></pre>
<p>If all goes well, you'll see some instructions to enable and start the <code>headscale</code> service. Let's do so.</p>
<pre><code class="language-bash">sudo systemctl enable headscale
sudo systemctl start headscale
</code></pre>
<p>Now comes the configuration part. We'll start with the users.</p>
<h2 id="create-headscale-users"><a class="header" href="#create-headscale-users">Create Headscale users</a></h2>
<p>For now, we'll just create one user, but for your real network, you can make as many as you need. Remember that machines are associated with users, so think about how you want to link those conceptually.</p>
<pre><code class="language-bash">sudo headscale users create hope -d hope-demo
</code></pre>
<p>And right away we'll create a preauthkey for use when we're ready to connect a client.</p>
<pre><code class="language-bash">sudo headscale preauthkeys create -u 1
</code></pre>
<p>Copy that and save it for later.</p>
<h2 id="configure-headscale-server"><a class="header" href="#configure-headscale-server">Configure Headscale Server</a></h2>
<p>Now we need to edit the Headscale config to match our domain. Got the domain you intend to use? Great. We don't need to modify the DNS records <em>yet</em>, but it's coming up. For now, use Nano, Vim, or Helix (<code>sudo snap install helix --classic</code>). With any of those, open up <code>/etc/headscale/config.yaml</code> with <code>sudo</code>.</p>
<p>Change <code>server_url</code> to <code>https://the-domain-you-chose.com:443</code></p>
<p>Change <code>listen_addr</code> to <code>0.0.0.0:443</code></p>
<p>Change <code>acme_email</code> to an email address you feel comfortable giving to LetsEncrypt.</p>
<p>Change <code>tls_letsencrypt_hostname</code> to <code>the-domain-you-chose.com</code></p>
<p>And that's all we need to change for now. If you looked closely at the setup for Headscale in our recipes, you saw we configured a custom certificate for Headscale on startup. But now that we're on the internet proper, we can use <a href="https://letsencrypt.org">LetsEncrypt</a> to grab a certificate.</p>
<p>Save and quit.</p>
<h2 id="configure-dns"><a class="header" href="#configure-dns">Configure DNS</a></h2>
<p>Time to head to your DNS registrar! Create a new <code>A</code> record for the domain name you've selected and point it at the IP address of your cloud VM.</p>
<p>Give it a few minutes for the record to propagate. You can test it with <code>nslookup the-domain-you-chose.com</code>.</p>
<p>Once it's ready, head back to your server and restart Headscale.</p>
<pre><code class="language-bash">sudo systemctl daemon-reload
sudo systemctl restart headscale
</code></pre>
<h2 id="connect-a-client-or-two"><a class="header" href="#connect-a-client-or-two">Connect a Client Or Two</a></h2>
<p>Now comes the fun part. Using the Tailscale Client, connect to the Headscale server. Here's how it looks on Linux:</p>
<pre><code class="language-bash">sudo tailscale up --login-server=https://the-domain-you-chose.com --auth-key=the-authkey-you-created --accept-routes
</code></pre>
<p>Congratulations! You've created a Headscale network.</p>
<h2 id="going-further"><a class="header" href="#going-further">Going Further</a></h2>
<p>Now that you have a way of connected trusts endpoints and networks together for secure communications, you can explore using some of these endpoints as <a href="https://tailscale.com/kb/1103/exit-nodes">exit nodes</a> to alter where your internet traffic comes from. You can also explore <a href="https://tailscale.com/kb/1054/dns">DNS</a> for your network to make it easier to reference endpoints.</p>
<p>You can also explore <a href="https://headscale.net/stable/ref/acls/">access control</a> for more granular control of your hosts.</p>
<p>But for now, take a moment and congratulate yourself. You've just taken a big step toward owning your digital privacy. You're using the cloud, but on your terms.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
